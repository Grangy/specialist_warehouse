# Восстановление БД и артикулов

## Что случилось: удалились артикулы, полетела база, сломалась статистика

Три вещи сразу (артикулы пропали, база «полетела», статистика сломалась) обычно даёт **одна из двух ситуаций**.

### 1. Восстановили БД из старого бэкапа

После сбоя или «полетевшей» базы подставили **файл БД с бэкапа**. Если бэкап был сделан **до** того, как:
- на сервере появилась колонка `art` и её успели заполнить, или  
- были применены миграции со статистикой (ranking, task_statistics, daily_stats),

то в восстановленной базе:
- **артикулов нет** — в том снимке их либо не было (колонки/данных), либо они не заполнялись;
- **статистика «сломана»** — таблиц/полей статистики нет или они от старой версии, приложение падает на запросах к ним;
- **база «полетела»** — вы видели сбой до восстановления; после подстановки бэкапа база уже «целая», но **содержимое старое**.

Итог: никто в коде артикулы не удалял — вы откатились к состоянию, где их ещё не было (или не было актуальной статистики).

### 2. Миграции прервались посередине

В проекте есть миграции, которые делают **пересоздание таблицы**: создают новую, копируют данные, удаляют старую, переименовывают. Например:
- `add_confirmation_progress_fields` — пересоздаёт `shipment_lines` и `shipment_task_lines`;
- `add_deleted_field_to_shipments` — пересоздаёт `shipments`;
- `add_role_type_to_task_statistics` — пересоздаёт `task_statistics`;
- и другие.

Если в этот момент **процесс убит** (обрыв SSH, `kill`, нехватка памяти, диск заполнен):
- старая таблица уже **DROP**, новая ещё не переименована или не создана — **данные или часть таблиц теряются**;
- схема и таблица `_prisma_migrations` расходятся — при следующем запуске миграции или приложения всё **«летит»** (ошибки, отсутствующие таблицы/колонки);
- **статистика «ломается»** — если прервалась миграция по `task_statistics` / ranking.

Миграция **только с добавлением колонки** `art` (`add_art_field_to_shipment_line`) сама по себе данные не трогает и артикулы не удаляет. Но если до или после неё прервалась другая миграция (пересоздание таблиц), последствия выглядят как «удалились артикулы, полетела база, сломалась статистика» одновременно.

### Что делать сейчас

- Если есть **бэкап с нужными данными** (артикулы и статистика уже есть) — восстановить из него и **не** гонять миграции заново без понимания состояния.
- Если бэкапа нет или он старый — восстановить работоспособность можно только из этого бэкапа, затем **аккуратно** применить миграции (см. ниже) при **остановленном приложении**.
- Артикулы после восстановления можно снова заполнить из базы по названию (JSON) или эвристикой из `name` — см. разделы ниже.

---

## Почему после миграции могла «полететь» база на сервере

Сама миграция `add_art_field_to_shipment_line` **только добавляет** колонку `art` (один `ALTER TABLE ... ADD COLUMN`). Она **не удаляет и не меняет** существующие данные. Если на сервере база «полетела» (ошибки, потеря данных, приложение не стартует), причина почти наверняка не в тексте этой миграции, а в **условиях** её выполнения или в **других миграциях**, которые шли до/после.

Возможные причины:

1. **Миграция запускалась при работающем приложении**  
   SQLite допускает только одного писателя. Если в этот момент приложение (Next.js, PM2) держало соединение и что-то писало в БД, могла возникнуть блокировка, таймаут или прерванная операция. В худшем случае — повреждение файла БД.

2. **Миграция прервалась**  
   Обрыв SSH, нехватка памяти, `kill` процесса во время `prisma migrate deploy` — миграция может не дойти до конца. Часть миграций применится, часть — нет; таблица `_prisma_migrations` и реальная схема разъедутся. Дальнейшие запуски миграций или приложения могут падать или вести себя непредсказуемо.

3. **Применили не те миграции или не в том порядке**  
   На сервере мог быть старый снимок кода/миграций, потом догнали до актуального. Если между этим меняли схему вручную или восстанавливали БД из бэкапа с другой версией — состояние БД и список миграций перестают соответствовать друг другу.

4. **Нет места на диске / нет прав**  
   Во время миграции SQLite создаёт временные структуры. Нехватка места или права только на чтение могут привести к сбою записи и к «битой» базе или к ошибкам при следующем старте.

5. **После миграции не перезапустили приложение / не перегенерировали Prisma Client**  
   Если не сделали `npx prisma generate` и перезапуск (например, `pm2 restart`), приложение может работать со старым клиентом и сыпать ошибками при обращении к новым полям. Это выглядит как «всё сломалось», хотя файл БД может быть цел.

**Что делать в следующий раз (безопасный порядок на сервере):**

1. Сделать **бэкап файла БД** (`prisma/*.db`) перед любыми миграциями.
2. **Остановить приложение** (например, `pm2 stop 0`), чтобы не было активных записей в SQLite.
3. Выполнить:
   ```bash
   cd /var/www/specialist_warehouse
   npx prisma migrate deploy
   npx prisma generate
   npm run build
   pm2 start 0
   ```
4. Если что-то пошло не так — **не запускать миграции повторно** до выяснения; восстановить БД из бэкапа при необходимости.

**Диагностика:** на сервере можно запустить аудит состояния БД (целостность, таблицы, миграции, артикулы, статистика):
```bash
npm run audit:db
# или: npx tsx scripts/audit-db-what-happened.ts
```
Скрипт выведет, чего не хватает, и подскажет возможные причины.

**Если база уже «полетела»:** восстановить из последнего бэкапа, затем снова выполнить миграции по шагам выше (остановив приложение). Если бэкапа нет — варианты только проверка целостности (`sqlite3 prisma/dev.db "PRAGMA integrity_check;"`) и точечный разбор ошибок в логах приложения и Prisma.

---

## Откат БД «до миграции»

Миграция `20251225101019_add_art_field_to_shipment_line` **только добавляет** колонку `art` в таблицу `shipment_lines`:

```sql
ALTER TABLE "shipment_lines" ADD COLUMN "art" TEXT;
```

Она **ничего не удаляет и не переносит**. Если на сервере во всех строках `art = NULL`, значит артикулы в эту БД никогда не записывались (заказы создавались без поля `art` или выгрузка из 1С его не передаёт).

### Как откатить БД к состоянию «до этой миграции»

1. **Нужен файловый бэкап** базы (например `prisma/dev.db` или `prisma/production.db`) с того момента, когда миграция ещё не была применена.
2. Остановить приложение, подменить файл БД на бэкап, запустить приложение.
3. После отката в базе **не будет колонки `art`**. Если снова выполнить `npx prisma migrate deploy`, миграция снова добавит колонку (пустую). То есть откат к «до миграции» **не восстанавливает артикулы** — их в том состоянии и не было в этой копии БД.

**Итог:** откат к «до миграции» имеет смысл только если вы хотите убрать колонку и откатить все изменения после бэкапа. Чтобы именно **появились артикулы**, нужен либо бэкап, где они уже были заполнены, либо восстановление из другого источника (см. ниже).

---

## Восстановление артикулов

### 1. Восстановление из поля `name` (эвристика)

Во многих позициях артикул дублируется в начале названия (например: `211015 Сверло...`, `А-43 Перчатки...`). Скрипт пытается взять первый «токен» из `name` и записать его в `art`, если он похож на артикул (есть цифра или паттерн типа `А-43`).

**Запуск (сначала только просмотр):**
```bash
npx tsx scripts/restore-art-from-name.ts
```

**Запись в БД:**
```bash
npx tsx scripts/restore-art-from-name.ts --apply
```

После выполнения проверка: `npm run audit:art`.

### 2. База артикулов по названию (JSON): локаль → сервер

Безопасный способ: собрать на локальной БД (где артикулы есть) базу «название → артикул», выгрузить её на сервер и по ней заполнить артикулы только у активных/завершённых заказов.

**Шаг 1 — локально:** экспорт из локальной БД в JSON:
```bash
npm run export:art
# или: npx tsx scripts/export-art-by-name.ts
```
Создаётся/обновляется файл `scripts/art-by-name-base.json` (нормализованные названия → артикул).

**Шаг 2:** загрузить этот файл на сервер (git, scp и т.п.), чтобы на сервере был путь `scripts/art-by-name-base.json`.

**Шаг 3 — на сервере:** применить базу к строкам без артикула (только заказы со статусами new, pending_confirmation, processed, confirmed и не удалённые):
```bash
# Сначала только просмотр
npm run apply:art
# или: npx tsx scripts/apply-art-from-base.ts

# Запись в БД
npx tsx scripts/apply-art-from-base.ts --apply
```

Сопоставление по **нормализованному названию** (пробелы сжаты, trim). Обновляются только строки, у которых артикул пустой и заказ подходит по статусу.

### 3. Восстановление из бэкапа, где артикулы уже есть

Если есть копия БД (например с другой машины), где в `shipment_lines` заполнено поле `art`:

- можно подставить эту БД вместо текущей (полная замена), или
- выгрузить из бэкапа пары `(id, art)` или `(shipment_id, sku, art)` и обновить текущую БД по совпадению `id` или `(shipment_id, sku)`.

### 4. Пропала инфа, какие заказы выгружены в 1С (грузит всю базу завершённых)

Эндпоинт **GET /api/shipments/ready-for-export** отдаёт заказы с `status='processed'`, `exportedTo1C=false`, `deleted=false`. Если у **всех** завершённых заказов флаг `exportedTo1C` сброшен или не проставлялся — в выборку попадает вся база завершённых.

**Аудит на сервере:**
```bash
npm run audit:export-1c
# или: npx tsx scripts/audit-export-1c.ts
```
Скрипт покажет: сколько заказов processed с флагом «выгружен» / «не выгружен», сколько попадёт в ready-for-export, примеры записей и возможную причину.

**Типичные причины:** восстановление из бэкапа (где флаги не ставились), 1С не вызывает **POST /api/shipments/sync-1c** с `success: true` после приёма заказа.

**Если старые заказы уже выгружались в 1С** — пометить их выгруженными:
```bash
npx tsx scripts/mark-all-processed-as-exported.ts
```
(При необходимости отредактировать скрипт, например ограничить по дате.)

### 5. Дальше: откуда брать артикулы при создании заказов

Чтобы новые заказы приходили с артикулами, источник данных (1С или другой импорт) при создании заказа (POST `/api/shipments`) должен передавать в каждой строке поле `art`. В коде оно уже сохраняется: `art: line.art || null` при создании позиций.
