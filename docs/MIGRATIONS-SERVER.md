# Миграции на сервере: как применять, чтобы ничего не отвалилось

## Главное правило

**Миграция должна применяться к той же базе, к которой подключается приложение.**

И приложение, и команда `prisma migrate deploy` берут путь к БД из переменной **DATABASE_URL**. Если у них разные значения (разные .env, разное окружение), миграция изменит один файл БД, а приложение будет читать другой — и появятся ошибки вида «column does not exist».

---

## Как узнать, куда подключается Prisma (откуда берётся DATABASE_URL)

### 1. Какой URL видит Prisma CLI (migrate deploy)

При запуске `prisma migrate deploy` Prisma выводит строку вроде:

```
Datasource "db": SQLite database "dev.db" at "file:/путь/к/файлу.db"
```

Это и есть база, к которой применится миграция. Запомните этот путь.

**Откуда берётся значение:**

- Читается **prisma.config.ts** в корне проекта (если есть). В нём подключается `dotenv/config` и `env("DATABASE_URL")`.
- `dotenv/config` при загрузке подхватывает `.env` из **текущей рабочей директории** (откуда вы вызвали команду). Если вы в корне проекта — это `.env` проекта.
- Если `DATABASE_URL` уже задана в окружении (export в .bashrc, systemd, PM2, другой .env), она может перекрыть значение из `.env` проекта — в зависимости от порядка загрузки.
- В **prisma.config.ts** относительный путь `file:./prisma/dev.db` превращается в абсолютный относительно **каталога, где лежит prisma.config.ts** (корень проекта), а не относительно текущей директории.

**Проверить явно, какой URL видит Prisma:**

```bash
cd /var/www/specialist_warehouse   # или ваш путь к проекту
npx prisma migrate status
```

В выводе будет строка `Datasource "db": ...` — это и есть фактический URL для миграций.

### 2. Какой URL видит приложение (Next.js)

Приложение берёт `DATABASE_URL` из **process.env** в момент старта. Его задаёт:

- Next.js: загружает `.env` из **корня проекта** (откуда запущен `next build` / `next start`).
- PM2 / systemd: если в конфиге задан `env: { DATABASE_URL: "..." }` или `Environment=DATABASE_URL=...`, то используется оно.

**Проверить, какой путь реально использует приложение:**

Временно в **src/lib/prisma.ts** после строки с `finalDatabaseUrl` можно добавить лог (только для проверки, потом убрать):

```ts
console.log('[Prisma] DATABASE_URL resolved:', finalDatabaseUrl?.replace(/file:(.*)/, '$1'));
```

Перезапустить приложение и посмотреть лог при первом запросе к БД. Либо добавить временный API-роут, который возвращает `process.env.DATABASE_URL` (без вывода в публичный лог, если там секреты).

### 3. Где искать настройки

| Источник | Где смотреть |
|----------|----------------|
| Проект | Файл **.env** в корне репозитория (`/var/www/specialist_warehouse/.env` и т.п.). |
| Prisma CLI | Тот же .env, если команду запускаете из корня проекта; плюс **prisma.config.ts** (логика пути). |
| Шелл | `echo $DATABASE_URL` в той же сессии, из которой запускаете миграцию. Если не пусто — эта переменная может перекрывать .env. |
| PM2 | `pm2 show specialist-warehouse` (или ваш id), блок env; или `ecosystem.config.js` / `pm2.config.js`. |
| systemd | `systemctl show your-app-service --property=Environment` или смотреть `Environment=` в unit-файле. |

### 4. Почему миграция «уехала» не туда — типичные случаи

1. **В шелле уже задан DATABASE_URL** (в .bashrc, .profile, экспорт в текущей сессии) — Prisma при `migrate deploy` берёт его, а приложение при старте через PM2/systemd — нет (или наоборот).
2. **Разные .env**: миграцию запускаете из другой директории, и подхватывается другой `.env` (например, из домашней папки или родительского каталога).
3. **PM2/systemd передают свой DATABASE_URL** приложению, а вы миграцию гоняете из шелла без этого окружения — миграция идёт в базу из .env проекта, приложение — в базу из конфига PM2/systemd.

**Что сделать:** один раз явно сравнить два пути — из вывода `prisma migrate status` и из лога приложения (или из `process.env.DATABASE_URL` в коде). Если они разные — выравнять: либо везде использовать один .env, либо явно задавать один и тот же `DATABASE_URL` при запуске и миграций, и приложения.

**Быстрая проверка на сервере:**

```bash
cd /var/www/specialist_warehouse   # корень проекта
echo "=== DATABASE_URL в текущей оболочке ==="
echo "$DATABASE_URL"
echo "=== .env в проекте (если есть) ==="
grep DATABASE_URL .env 2>/dev/null || echo "(файл .env не найден или переменной нет)"
echo "=== Куда подключается Prisma CLI ==="
npx prisma migrate status 2>&1 | grep -i datasource
```

Если в первой строке вывода есть путь — он может перекрывать .env при запуске `prisma migrate deploy`. Путь из последней строки — та БД, к которой реально подключаются миграции.

---

## Как правильно применить миграции на сервере

### 1. Убедиться, откуда приложение берёт DATABASE_URL

На сервере приложение (Next.js / PM2 / systemd) обычно запускается из **корня проекта** и подхватывает `.env` из этой папки. В `.env` должна быть строка:

```env
DATABASE_URL="file:./prisma/dev.db"
```

или абсолютный путь к файлу БД на сервере, например:

```env
DATABASE_URL="file:/var/www/sklad_spec/prisma/dev.db"
```

Запомните: **именно этот путь** должен использовать миграция.

### 2. Запускать миграцию из корня проекта с тем же .env

Перейдите в каталог проекта и выполните миграцию **без переопределения** DATABASE_URL:

```bash
cd /путь/к/проекту/sklad_spec
npx prisma migrate deploy
```

При этом в текущей директории должен лежать тот же `.env`, из которого запускается приложение (с тем же `DATABASE_URL`). Тогда Prisma подключится к той же БД, что и приложение.

### 3. Если на сервере нет .env в проекте

Если переменные задаются через systemd, PM2 env или другой менеджер, то и миграцию нужно запускать так, чтобы она видела тот же `DATABASE_URL`. Варианты:

**Вариант A — подставить URL явно (если знаете путь к БД):**

```bash
cd /путь/к/проекту/sklad_spec
DATABASE_URL="file:/полный/путь/к/prisma/dev.db" npx prisma migrate deploy
```

Подставьте тот же путь, который использует приложение.

**Вариант B — использовать .env приложения:**

```bash
cd /путь/к/проекту/sklad_spec
set -a && source .env && set +a   # Linux/macOS: загрузить .env в текущую оболочку
npx prisma migrate deploy
```

Так миграция увидит тот же `DATABASE_URL`, что и приложение.

### 4. После деплоя нового кода (с новой миграцией)

Рекомендуемый порядок:

1. Остановить приложение (или перевести в режим обслуживания).
2. Выполнить `npx prisma migrate deploy` из корня проекта с правильным `DATABASE_URL` (см. выше).
3. Убедиться, что команда завершилась без ошибок.
4. Запустить приложение снова.

Так вы избежите ситуации, когда приложение уже обращается к новой схеме (по новому коду), а миграция ещё не применена.

---

## Локальная разработка

Та же логика: миграция и приложение должны использовать один и тот же `DATABASE_URL`.

- Обычно в корне проекта лежит `.env` с `DATABASE_URL="file:./prisma/dev.db"`.
- Запускайте миграции из корня проекта: `npx prisma migrate deploy` или `npx prisma migrate dev`.
- Не задавайте в системе (или в другом .env) другой `DATABASE_URL`, иначе получите две разные базы (как было с `pinned_at`).

---

## Проверка после миграции

Убедиться, что колонка/таблица появилась в нужной БД:

```bash
# Для SQLite (подставьте путь к вашему dev.db)
sqlite3 prisma/dev.db "PRAGMA table_info(shipments);"
```

В списке должна быть нужная колонка (например, `pinned_at`).

---

## Если миграция «применилась», но колонки в БД нет

Такое бывает, когда `prisma migrate deploy` подключается к другой базе (другой DATABASE_URL), чем та, которую использует приложение. В результате запись о миграции попадает в одну БД, а приложение читает другую.

**Что сделать на сервере** (в каталоге проекта, с тем же путём к БД, что в .env приложения):

```bash
# 1. Добавить колонку в ту БД, к которой реально подключается приложение
sqlite3 prisma/dev.db "ALTER TABLE shipments ADD COLUMN pinned_at DATETIME;"

# 2. Отметить миграцию как применённую (чтобы при следующем deploy не было ошибки «duplicate column»)
npx prisma migrate resolve --applied 20260126120000_add_pinned_at_to_shipments
```

После этого перезапустить приложение.

---

## Итог

| Где        | Действие |
|-----------|----------|
| Сервер    | Запускать `npx prisma migrate deploy` из корня проекта, с тем же `.env` / `DATABASE_URL`, что и у приложения. Перед деплоем нового кода — сначала миграция, потом перезапуск приложения. |
| Локально  | Запускать миграции из корня проекта, не переопределять `DATABASE_URL` в окружении, чтобы не было двух разных баз. |
