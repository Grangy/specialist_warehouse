# Аудит: тяжёлые Prisma-запросы при аналитике

## Что за запросы в логе

В консоли видны серии запросов:

1. **`shipment_tasks`** — выборка заданий с `status = 'processed'`, `confirmed_at IS NOT NULL`, `checker_id IS NOT NULL`, сортировка по `confirmed_at DESC`, с `LIMIT ? OFFSET ?`.
2. **`users`** — несколько запросов с `id IN (?,?,?,...)` (подгрузка checker/collector).
3. **`shipment_task_lines`** — один или несколько запросов с **очень длинным** `task_id IN (?,?,?,...)` (сотни id).
4. **`shipments`** — запросы с `id IN (?,?,?,...)` (подгрузка заказов).

Это **нормальное** поведение для текущей реализации: так отрабатывают эндпоинты аналитики, когда в админке открывают вкладку с отчётами по проверяльщикам/сборщикам/обзору.

---

## Источники запросов

Один и тот же паттерн (загрузка всех подходящих заданий с `include: lines`, пользователи, заказы) используется в:

| Эндпоинт | Назначение | Условие по заданиям |
|----------|------------|----------------------|
| `GET /api/analytics/checkers` | Аналитика по проверяльщикам | `status: 'processed'`, `confirmedAt`, `checkerId` |
| `GET /api/analytics/collectors` | Аналитика по сборщикам | `status: 'pending_confirmation'`, `completedAt`, `collectorId` |
| `GET /api/analytics/overview` | Обзор аналитики | `completedAt` или `confirmedAt` не null |
| `GET /api/analytics/all-users` | Аналитика по всем пользователям | то же |

В логе с `ORDER BY confirmed_at DESC` и `checker_id IS NOT NULL` запросы идут из **`/api/analytics/checkers`** (открытие вкладки «Проверяльщики» в админке).

---

## Почему запросы выглядят тяжёлыми

1. **Загрузка всех заданий без ограничения по дате в БД**  
   В коде сначала делается `findMany` по всем подходящим заданиям (без `take`/пагинации), затем фильтр по датам выполняется в JavaScript. При большом числе заданий это даёт:
   - много строк из `shipment_tasks`;
   - при использовании SQLite Prisma может разбивать выборку на батчи (отсюда `LIMIT ? OFFSET ?`).

2. **`include: { lines: true }`**  
   Для каждого задания подгружаются все строки (`shipment_task_lines`). В итоге один запрос с огромным `task_id IN (...)` и десятки тысяч строк, если заданий много.

3. **Отдельные запросы по связям**  
   После выборки заданий Prisma догружает:
   - пользователей (checker/collector) — несколько `users` с `id IN (...)`;
   - заказы — `shipments` с `id IN (...)`.

Итого: один «тяжёлый» сценарий (например, открытие аналитики проверяльщиков) порождает несколько больших запросов, в том числе с длинным `IN` по `task_id`.

---

## Нормально ли это

- **В разработке** — да: в логе просто видно, как Prisma разбивает один `findMany` с `include` на несколько SQL-запросов и батчи.
- **В проде** при большом объёме данных (тысячи заданий и строк) это может приводить к:
  - высокому потреблению памяти (все задания и линии в памяти);
  - долгим ответам аналитики;
  - нагрузке на БД из-за больших `IN (...)` и объёма данных.

---

## Рекомендации

### 1. Фильтровать по дате в БД, а не в JS

Во всех перечисленных эндпоинтах уже есть диапазон дат (`startDate`, `endDate`). Имеет смысл перенести фильтр в `where`:

```ts
// Было (условно): findMany по всем, потом .filter(task => ...)
// Стало:
where: {
  status: 'processed',
  confirmedAt: {
    not: null,
    gte: startForQuery,
    lte: endForQuery,
  },
  checkerId: { not: null },
},
```

Аналогично для collectors/overview/all-users: использовать `completedAt`/`confirmedAt` в `where` вместо фильтрации массива в коде.

### 2. Не тянуть `lines`, если они не нужны для отчёта

В аналитике по проверяльщикам/сборщикам часто нужны только агрегаты (количество заданий, позиций, единиц). Если построчные данные по `lines` не используются, убрать `include: { lines: true }` и считать объёмы из уже имеющихся полей задания (`totalItems`, `totalUnits`) или одним отдельным агрегирующим запросом.

### 3. Ограничить выборку или ввести пагинацию

- Либо жёстко ограничить выборку, например `take: 5000`, с явной сортировкой и фильтром по дате в `where`.
- Либо ввести пагинацию (параметры `page`/`limit` или `cursor`) и отдавать аналитику порциями.

### 4. Логирование запросов в проде

Сейчас в `src/lib/prisma.ts` включено `log: ['query', 'error', 'warn']` только при `NODE_ENV === 'development'`. В проде логи запросов отключены — это нормально. При необходимости отладки на проде можно временно включить логирование только для конкретных маршрутов или отключить после снятия метрик.

---

## Кратко

- Запросы в логе — от **аналитики** (в первую очередь `/api/analytics/checkers` при открытии вкладки).
- Поведение ожидаемое для текущей реализации, но при росте данных станет узким местом.
- Имеет смысл: фильтровать по дате в `where`, убрать лишний `include: lines` там, где он не нужен, и при необходимости ограничить или пролистать выборку (пагинация/`take`).
