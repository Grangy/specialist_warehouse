# Аудит рейтинга топа дня: почему место определяется баллами, а не позициями

## Вопрос

Роман в топе на 1 месте: 55 поз., 204 ед., 6 зак., **103.37 баллов**, 152 PPH.  
Станислав на 2 месте: 186 поз., 1104 ед., 11 зак., **97.72 баллов** (из них 47.86 — диктовщик), 26 PPH.  
Почему при большем числе позиций у Станислава он ниже Романа?

## Ответ

**Места в топе считаются по сумме баллов (points), а не по количеству позиций.**  
Баллы зависят от **скорости** (эффективности): одна и та же позиция даёт больше баллов при быстрой работе и меньше — при медленной.

## Формула баллов

1. **По каждому заданию** (сборка/проверка/диктовка):
   - `base_points = positions + K*units + M*switches` (по умолчанию K=0, M=3).
   - `efficiency = expected_time / pick_time` (нормативное время / фактическое).
   - `efficiency_clamped = clamp(efficiency, 0.9, 1.1)` — скорость влияет на баллы максимум ±10%.
   - `order_points = base_points * efficiency_clamped`.

2. **Итог за день** по пользователю:
   - `points = сумма order_points` по всем его заданиям за день (сборщик + проверяльщик + диктовщик).

3. **Сортировка топа**: `allRankings.sort((a, b) => b.points - a.points)` — по убыванию баллов.

## Результаты аудита (скрипт `npm run audit:top-ranking`)

### Роман (1 место)

- **103.37 баллов**, все от сборки (диктовщик: 0).
- 7 заданий, 55 поз., 204 ед., 6 зак.
- У многих заданий **высокая эффективность** (1.37, 1.50, …) → быстрая работа → множитель до 1.1 (после изменения формулы).
- PPH 152.

### Станислав (2 место)

- **97.72 балла**: 49.86 от сборки + 47.86 от диктовки.
- 11 заданий как сборщик, 9 как диктовщик.
- У многих заданий как сборщик **низкая эффективность** (0.50 — нижний порог) → медленная работа → множитель 0.9 (после изменения формулы).
- 186 поз., 1104 ед., 11 зак., PPH 26.

Итог: при меньшем числе позиций Роман набрал больше баллов за счёт высокой эффективности; у Станислава больше позиций, но низкая эффективность по многим заданиям, поэтому сумма баллов меньше.

## Проверка расчёта

- Запросы и агрегация в скрипте `scripts/audit-top-ranking.ts` повторяют логику `GET /api/statistics/top`:
  - сборщики по `completedAt` за день;
  - проверяльщики по `confirmedAt` за день;
  - сборки проверяльщиков (collector, role=checker);
  - диктовщики по `confirmedAt` и `dictatorId = user.id`.
- Двойного учёта нет: баллы диктовщика хранятся в отдельных строках TaskStatistics (orderPoints = 0.75 от баллов проверки).
- Расчёт баллов (basePoints, efficiencyClamped, orderPoints) совпадает с `src/lib/ranking/calculations.ts` и данными в БД.

**Вывод: ошибки в расчёте нет.** Порядок мест корректен при текущей формуле (рейтинг по баллам с учётом скорости).

## Как перезапустить аудит

```bash
npm run audit:top-ranking
# или за конкретную дату:
tsx scripts/audit-top-ranking.ts 2025-01-26
```

## Если нужно менять логику топа

Варианты (продуктовые решения, не исправление бага):

1. **Оставить как есть** — рейтинг по баллам (учитывается скорость и диктовка).
2. **Дополнительная сортировка по позициям** при равенстве баллов: `sort((a,b) => b.points - a.points || b.positions - a.positions)`.
3. **Отдельный блок «Топ по позициям»** на странице `/top` при желании показывать и объём, и баллы.
